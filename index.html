<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TutorDeck Studio</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM from CDN -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
    <!-- Babel Standalone to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-900">
    <div id="root"></div>

    <!-- All React/TypeScript code is now inside this script tag -->
    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useCallback, useEffect } from 'react';
        import ReactDOM from 'react-dom/client';

        // --- From types.ts ---
        const RecordingStatus = {
          IDLE: 'idle',
          GETTING_PERMISSION: 'getting_permission',
          RECORDING: 'recording',
          STOPPED: 'stopped',
          ERROR: 'error',
        };

        // --- From icons/WaveformIcon.tsx ---
        const WaveformIcon = (props) => (
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            fill="none" 
            viewBox="0 0 24 24" 
            strokeWidth={1.5} 
            stroke="currentColor" 
            {...props}
          >
            <path 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                d="M3.75 9.75h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zM7.5 6.75h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zM11.25 4.5h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm1.5-18h-1.5a.75.75 0 000 1.5h1.5a.75.75 0 000-1.5zm3 18h-1.5a.75.75 0 000 1.5h1.5a.75.75 0 000-1.5zm-3-1.5h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0-3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0-3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0-3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm-3 4.5h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0-3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zM15 6.75h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm3.75-12h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5zm0 3h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 000 1.5z" 
            />
          </svg>
        );

        // --- From icons/DownloadIcon.tsx ---
        const DownloadIcon = (props) => (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth={1.5}
            stroke="currentColor"
            {...props}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3"
            />
          </svg>
        );

        // --- From icons/MicrophoneIcon.tsx ---
        const MicrophoneIcon = (props) => (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth={1.5}
            stroke="currentColor"
            {...props}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M12 18.75a6 6 0 006-6v-1.5a6 6 0 00-12 0v1.5a6 6 0 006 6z"
            />
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M19.5 12a7.5 7.5 0 11-15 0"
            />
          </svg>
        );

        // --- From icons/StopIcon.tsx ---
        const StopIcon = (props) => (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            {...props}
          >
            <path
              fillRule="evenodd"
              d="M4.5 7.5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-9a3 3 0 01-3-3v-9z"
              clipRule="evenodd"
            />
          </svg>
        );

        // --- From hooks/useOpusRecorder.ts ---
        const useOpusRecorder = () => {
          const [status, setStatus] = useState(RecordingStatus.IDLE);
          const [audioUrl, setAudioUrl] = useState(null);
          const [recordingTime, setRecordingTime] = useState(0);
          const [error, setError] = useState(null);

          const mediaRecorderRef = useRef(null);
          const audioChunksRef = useRef([]);
          const timerIntervalRef = useRef(null);
          const streamRef = useRef(null);

          const getSupportedMimeType = () => {
            const types = [
              'audio/opus',
              'audio/webm;codecs=opus',
              'audio/ogg;codecs=opus',
              'audio/webm',
              'audio/mp4',
            ];
            for (const type of types) {
              if (MediaRecorder.isTypeSupported(type)) {
                return type;
              }
            }
            return null;
          };

          const cleanup = useCallback(() => {
            if (timerIntervalRef.current) {
              clearInterval(timerIntervalRef.current);
              timerIntervalRef.current = null;
            }
            if (streamRef.current) {
              streamRef.current.getTracks().forEach(track => track.stop());
              streamRef.current = null;
            }
            if (mediaRecorderRef.current) {
                mediaRecorderRef.current.ondataavailable = null;
                mediaRecorderRef.current.onstop = null;
                mediaRecorderRef.current.onerror = null;
                mediaRecorderRef.current = null;
            }
            audioChunksRef.current = [];
          }, []);

          const resetRecording = useCallback(() => {
            cleanup();
            setAudioUrl(null);
            setRecordingTime(0);
            setError(null);
            setStatus(RecordingStatus.IDLE);
          }, [cleanup]);

          const startRecording = useCallback(async () => {
            resetRecording();

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
              setError('Media Devices API not supported in this browser.');
              setStatus(RecordingStatus.ERROR);
              return;
            }

            const mimeType = getSupportedMimeType();
            if (!mimeType) {
                setError('No supported audio format found for recording.');
                setStatus(RecordingStatus.ERROR);
                return;
            }
            
            setStatus(RecordingStatus.GETTING_PERMISSION);

            try {
              const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
              streamRef.current = stream;
              setStatus(RecordingStatus.RECORDING);

              mediaRecorderRef.current = new MediaRecorder(stream, { mimeType });
              audioChunksRef.current = [];

              mediaRecorderRef.current.ondataavailable = (event) => {
                if (event.data.size > 0) {
                  audioChunksRef.current.push(event.data);
                }
              };

              mediaRecorderRef.current.onstop = () => {
                const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });
                const url = URL.createObjectURL(audioBlob);
                setAudioUrl(url);
                setStatus(RecordingStatus.STOPPED);
                cleanup();
              };
              
              mediaRecorderRef.current.onerror = (event) => {
                  setError(`Recording error: ${event.error.message}`);
                  setStatus(RecordingStatus.ERROR);
                  cleanup();
              };

              mediaRecorderRef.current.start();
              
              const startTime = Date.now();
              timerIntervalRef.current = window.setInterval(() => {
                setRecordingTime(Math.floor((Date.now() - startTime) / 1000));
              }, 1000);

            } catch (err) {
              let errorMessage = 'An unknown error occurred.';
              if (err instanceof Error) {
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                  errorMessage = 'Microphone permission was denied. Please allow access in your browser settings.';
                } else {
                    errorMessage = err.message;
                }
              }
              setError(errorMessage);
              setStatus(RecordingStatus.ERROR);
              cleanup();
            }
          }, [resetRecording, cleanup]);

          const stopRecording = useCallback(() => {
            if (mediaRecorderRef.current && status === RecordingStatus.RECORDING) {
              mediaRecorderRef.current.stop();
            }
          }, [status]);

          useEffect(() => {
            return () => {
              if (audioUrl) {
                  URL.revokeObjectURL(audioUrl);
              }
              cleanup();
            };
          }, [audioUrl, cleanup]);

          return { status, audioUrl, recordingTime, error, startRecording, stopRecording, resetRecording };
        };

        // --- From components/Timer.tsx ---
        const Timer = ({ seconds }) => {
          const formatTime = (timeInSeconds) => {
            const minutes = Math.floor(timeInSeconds / 60).toString().padStart(2, '0');
            const secs = (timeInSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${secs}`;
          };

          return (
            <div className="bg-gray-900/50 w-48 h-24 flex items-center justify-center rounded-xl border border-gray-700">
                <p className="text-5xl font-mono text-gray-50 tracking-wider">
                {formatTime(seconds)}
                </p>
            </div>
          );
        };

        // --- From components/StatusIndicator.tsx ---
        const StatusIndicator = ({ status }) => {
          const getStatusInfo = () => {
            switch (status) {
              case RecordingStatus.RECORDING:
                return { text: 'Recording...', color: 'bg-red-500', pulse: true };
              case RecordingStatus.STOPPED:
                return { text: 'Finished. Ready to download.', color: 'bg-emerald-500', pulse: false };
              case RecordingStatus.GETTING_PERMISSION:
                return { text: 'Requesting microphone...', color: 'bg-yellow-500', pulse: true };
              case RecordingStatus.ERROR:
                return { text: 'Error Occurred', color: 'bg-gray-500', pulse: false };
              case RecordingStatus.IDLE:
              default:
                return { text: 'Ready to Record', color: 'bg-gray-400', pulse: false };
            }
          };

          const { text, color, pulse } = getStatusInfo();

          return (
            <div className="flex items-center justify-center space-x-2 bg-gray-700/50 px-4 py-2 rounded-full">
              <span className={`relative flex h-3 w-3`}>
                <span className={`absolute inline-flex h-full w-full rounded-full ${color} ${pulse ? 'animate-ping opacity-75' : ''}`}></span>
                <span className={`relative inline-flex rounded-full h-3 w-3 ${color}`}></span>
              </span>
              <span className="text-sm text-gray-200">{text}</span>
            </div>
          );
        };

        // --- From components/DownloadButton.tsx ---
        const DownloadButton = ({ audioUrl }) => {
          if (!audioUrl) return null;

          return (
            <a
              href={audioUrl}
              download={`recording-${new Date().toISOString()}.opus`}
              className="w-full flex-1 flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-4 rounded-xl transition-colors duration-200"
            >
              <DownloadIcon className="w-5 h-5 mr-2" />
              Download Opus File
            </a>
          );
        };

        // --- From components/RecordButton.tsx ---
        const RecordButton = ({ status, onClick, disabled }) => {
          const isRecording = status === RecordingStatus.RECORDING;

          const buttonClasses = `
            w-full flex items-center justify-center text-xl font-semibold py-4 px-6 rounded-xl transition-all duration-300 ease-in-out transform focus:outline-none focus:ring-4
            ${disabled 
              ? 'bg-gray-600 text-gray-400 cursor-not-allowed' 
              : isRecording 
                ? 'bg-red-600 hover:bg-red-700 text-white focus:ring-red-400' 
                : 'bg-emerald-500 hover:bg-emerald-600 text-white focus:ring-emerald-400'
            }
          `;

          return (
            <button onClick={onClick} className={buttonClasses} disabled={disabled}>
              {isRecording ? (
                <>
                  <StopIcon className="w-7 h-7 mr-3" />
                  <span>Stop Recording</span>
                </>
              ) : (
                <>
                  <MicrophoneIcon className="w-7 h-7 mr-3" />
                  <span>Start Recording</span>
                </>
              )}
               {isRecording && <div className="absolute w-full h-full rounded-xl bg-red-500 animate-ping -z-10 opacity-50"></div>}
            </button>
          );
        };

        // --- From App.tsx ---
        const App = () => {
          const { 
            status, 
            audioUrl, 
            recordingTime, 
            error, 
            startRecording, 
            stopRecording,
            resetRecording 
          } = useOpusRecorder();

          const isRecording = status === RecordingStatus.RECORDING;
          const isStopped = status === RecordingStatus.STOPPED;

          const handleRecordButtonClick = () => {
            if (isRecording) {
              stopRecording();
            } else {
              startRecording();
            }
          };

          return (
            <div className="min-h-screen bg-gray-900 text-gray-300 flex flex-col items-center justify-center p-4 font-sans">
              <main className="w-full max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 space-y-6 flex flex-col items-center border border-gray-700">
                <div className="flex items-center space-x-3">
                  <WaveformIcon className="w-8 h-8 text-emerald-400" />
                  <h1 className="text-3xl font-bold text-gray-50">TutorDeck Studio</h1>
                </div>

                <StatusIndicator status={status} />

                <Timer seconds={recordingTime} />

                {error && (
                  <div className="bg-red-900/50 text-red-300 border border-red-700 rounded-lg p-3 text-center text-sm">
                    <p className="font-semibold">An Error Occurred</p>
                    <p>{error}</p>
                  </div>
                )}
                
                <div className="w-full pt-4 space-y-4">
                  <RecordButton 
                    status={status} 
                    onClick={handleRecordButtonClick} 
                    disabled={status === RecordingStatus.GETTING_PERMISSION || !!error}
                  />

                  {isStopped && audioUrl && (
                    <div className="flex flex-col sm:flex-row gap-4">
                        <DownloadButton audioUrl={audioUrl} />
                        <button
                            onClick={resetRecording}
                            className="w-full flex-1 text-center bg-gray-600 hover:bg-gray-500 text-gray-50 font-semibold py-3 px-4 rounded-xl transition-colors duration-200"
                        >
                            Record Again
                        </button>
                    </div>
                  )}
                </div>
              </main>
              <footer className="text-center mt-8 text-gray-500 text-sm">
                <p>Record high-quality audio in a compressed format.</p>
                <p>&copy; {new Date().getFullYear()} TutorDeck Studio. All rights reserved.</p>
              </footer>
            </div>
          );
        };

        // --- From index.tsx ---
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          throw new Error("Could not find root element to mount to");
        }

        const root = ReactDOM.createRoot(rootElement);
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );
    </script>
</body>
</html>